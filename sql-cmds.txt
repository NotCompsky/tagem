CREATE DATABASE mytag;
USE mytag;

CREATE TABLE file (
    id BIGINT UNSIGNED NOT NULL AUTO_INCREMENT,
    name VARBINARY(1024),
    language_id BIGINT UNSIGNED,
    score INT,
    added_on DATETIME DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (id)
);

CREATE TABLE tag (
    id BIGINT UNSIGNED NOT NULL AUTO_INCREMENT,
    name VARBINARY(128),
    UNIQUE KEY (name),
    PRIMARY KEY (id)
);

CREATE TABLE tag2parent (
    tag_id BIGINT UNSIGNED NOT NULL,
    parent_id BIGINT UNSIGNED NOT NULL,
    PRIMARY KEY `tag2parent` (`tag_id`, `parent_id`)
);

CREATE TABLE file2tag (
    file_id BIGINT UNSIGNED NOT NULL,
    tag_id BIGINT UNSIGNED NOT NULL,
    PRIMARY KEY `file2tag` (file_id, tag_id)
);

CREATE TABLE instance (
    id BIGINT UNSIGNED NOT NULL AUTO_INCREMENT,
    name VARBINARY(128),
    file_id BIGINT UNSIGNED NOT NULL,
    frame_n BIGINT UNSIGNED NOT NULL,
    x DOUBLE NOT NULL,  # As proportion of (image|frame)'s width
    y DOUBLE NOT NULL,
    w DOUBLE NOT NULL,
    h DOUBLE NOT NULL,
    PRIMARY KEY (id)
);

CREATE TABLE instance2tag (
    instance_id BIGINT UNSIGNED NOT NULL,
    tag_id BIGINT UNSIGNED NOT NULL,  # ID of instance tag
    PRIMARY KEY `instance2tag` (`instance_id`, `tag_id`)
);

CREATE TABLE relation (
    id BIGINT UNSIGNED NOT NULL AUTO_INCREMENT,
    master_id BIGINT UNSIGNED NOT NULL,  # ID of master instance
    slave_id BIGINT UNSIGNED NOT NULL,
    PRIMARY KEY (id)
);

CREATE TABLE relation2tag (
    relation_id BIGINT UNSIGNED NOT NULL,
    tag_id BIGINT UNSIGNED NOT NULL,  # ID of instance tag
    PRIMARY KEY `instance2tag` (`relation_id`, `tag_id`)
);

CREATE TABLE relationtag2tag (
    # Decides on the tags a relation automatically gives rise to, given the tags of the master and slave object instances
    relation_id BIGINT UNSIGNED NOT NULL,
    master_id BIGINT UNSIGNED NOT NULL,  # Tag ID of one of the master's tags
    slave_id BIGINT UNSIGNED NOT NULL,
    tag_id BIGINT UNSIGNED NOT NULL,  # Resulting Tag ID
    PRIMARY KEY `relation2mst` (relation_id, master_id, slave_id, tag_id)
);



GRANT SELECT, INSERT, UPDATE, EXECUTE ON mytag.* TO 'ME'@'localhost';









# Useful commands




# Display heirarchy of tags

SELECT B.child, t.name as 'parent'
FROM tag t
RIGHT JOIN (
    SELECT t.name as 'child', A.parent_id
    FROM tag t
    JOIN (
        SELECT tag_id, parent_id
        FROM tag2parent
    ) A ON A.tag_id = t.id
) B ON B.parent_id = t.id
;




# Print all tags (including itself) descended from tag of ID `N`

DROP PROCEDURE IF EXISTS descendant_tags_id;

delimiter $$

CREATE PROCEDURE descendant_tags_id(seed INT UNSIGNED)
BEGIN
  -- Temporary storage
  DROP TABLE IF EXISTS _result;
  CREATE TEMPORARY TABLE _result (node INT UNSIGNED PRIMARY KEY);

  -- Seeding
  INSERT INTO _result VALUES (seed);

  -- Iteration
  DROP TABLE IF EXISTS _tmp;
  CREATE TEMPORARY TABLE _tmp LIKE _result;
  REPEAT
    TRUNCATE TABLE _tmp;
    INSERT IGNORE INTO _tmp SELECT tag_id AS node
      FROM _result JOIN tag2parent ON node = parent_id;

    INSERT IGNORE INTO _result SELECT node FROM _tmp;
  UNTIL ROW_COUNT() = 0
  END REPEAT;
  DROP TABLE _tmp;
  SELECT * FROM _result;
END $$

delimiter ;

## Usage: `CALL descendant_tags_id(N)`
## Slightly modified query from "Mats Kindahl" from "https://stackoverflow.com/questions/7631048/connect-by-prior-equivalent-for-mysql"




# The above, but using tag names rather than IDs

## Procedure defined same as above, but replacing seeding with:
  INSERT INTO _result (SELECT id FROM tag WHERE name = seed);
### and replacing argument with (seed VARBINARY(128))

DROP PROCEDURE IF EXISTS descendant_tags_name;

delimiter $$

CREATE PROCEDURE descendant_tags_name(seed VARBINARY(128))
BEGIN
  -- Temporary storage
  DROP TABLE IF EXISTS _result;
  CREATE TEMPORARY TABLE _result (node INT UNSIGNED PRIMARY KEY);

  -- Seeding
  INSERT INTO _result (SELECT id FROM tag WHERE name = seed);

  -- Iteration
  DROP TABLE IF EXISTS _tmp;
  CREATE TEMPORARY TABLE _tmp LIKE _result;
  REPEAT
    TRUNCATE TABLE _tmp;
    INSERT IGNORE INTO _tmp SELECT tag_id AS node
      FROM _result JOIN tag2parent ON node = parent_id;

    INSERT IGNORE INTO _result SELECT node FROM _tmp;
  UNTIL ROW_COUNT() = 0
  END REPEAT;
  DROP TABLE _tmp;
  SELECT * FROM _result;
END $$

delimiter ;

## Usage:
CALL descendant_tags_name("TAG_NAME");
SELECT name
FROM tag
JOIN _result ON node = id
;


# Find all files tagged with TAG_NAME or one of its descendant tag

CALL descendant_tags_id((SELECT id FROM tag WHERE name='TAG_NAME'));
SELECT *
FROM file
JOIN (
    SELECT file_id
    FROM file2tag
    WHERE tag_id IN (SELECT node FROM _result)
) A ON A.file_id = id
;



# Find all files tagged with (TAG1 or TAG2) or one of their descendant tags

## Procedures

DROP PROCEDURE IF EXISTS descendant_tags_id_init;
DROP PROCEDURE IF EXISTS descendant_tags_id_preseeded;
DROP PROCEDURE IF EXISTS descendant_tags_id_from;

delimiter $$

CREATE PROCEDURE descendant_tags_id_init(tbl VARBINARY(1024))
BEGIN
    set @query = concat("DROP TABLE IF EXISTS ", tbl, ";");
    PREPARE stmt FROM @query;
    EXECUTE stmt;
    
    set @query = concat("CREATE TEMPORARY TABLE ", tbl, " (node BIGINT UNSIGNED PRIMARY KEY);");
    PREPARE stmt FROM @query;
    EXECUTE stmt;
END $$

CREATE PROCEDURE descendant_tags_id_preseeded(tbl VARBINARY(1024))
BEGIN
    set @query_b = concat("INSERT IGNORE INTO _tmp SELECT tag_id AS node FROM ", tbl, " JOIN tag2parent ON node = parent_id;");
    set @query_d = concat("INSERT IGNORE INTO ", tbl, " SELECT node FROM _tmp;");
    PREPARE stmt_b FROM @query_b;
    PREPARE stmt_d FROM @query_d;
    REPEAT
        TRUNCATE TABLE _tmp;
        EXECUTE stmt_b;
        EXECUTE stmt_d;
    UNTIL ROW_COUNT() = 0
    END REPEAT;
END $$

CREATE PROCEDURE descendant_tags_id_from(tbl VARBINARY(1024),  str VARBINARY(1024))
BEGIN
    CALL descendant_tags_id_init(tbl);
    set @query = concat("INSERT INTO ", tbl, " (node) SELECT id FROM tag WHERE name IN (", str, ");");
    PREPARE stmt FROM @query;
    EXECUTE stmt;
    
    
    DROP TABLE IF EXISTS _tmp;
    
    set @query = concat("CREATE TEMPORARY TABLE _tmp LIKE ", tbl, ";");
    PREPARE stmt FROM @query;
    EXECUTE stmt;
    
    
    CALL descendant_tags_id_preseeded(tbl);
    #set @query = concat("SELECT * FROM ", tbl, ";");
    #PREPARE stmt FROM @query;
    #EXECUTE stmt;
END $$

delimiter ;

## Usage

CALL descendant_tags_id_from("_tmp_arg",  "'tagname', 'tagname2'");






DROP PROCEDURE IF EXISTS ancestor_tags_id_from;

delimiter $$

CREATE PROCEDURE ancestor_tags_id_rooted_from_id(tbl VARBINARY(1024),  tag_id INT)
BEGIN
    CALL ancestor_tags_id_rooted_init(tbl);
    set @query = concat("INSERT INTO ", tbl, " (node, depth) VALUES (", tag_id, ", 0);");
    PREPARE stmt FROM @query;
    EXECUTE stmt;
    
    
    DROP TABLE IF EXISTS _tmp;
    
    set @query = concat("CREATE TEMPORARY TABLE _tmp LIKE ", tbl, ";");
    PREPARE stmt FROM @query;
    EXECUTE stmt;
    
    
    CALL ancestor_tags_id_rooted_preseeded(tbl);
END $$

delimiter ;








# Get table of (file path, instance coords)  given tag names
# TODO: frame_n

SELECT name, tag_id, x, y, w, h
FROM file
JOIN (
    SELECT file_id, tag_id, x, y, w, h
    FROM instance
    JOIN (
        SELECT instance_id, tag_id
        FROM instance2tag
        WHERE tag_id IN (
            SELECT id
            FROM tag
            WHERE name IN ("tagname")
        )
    ) A ON A.instance_id = id
) B ON B.file_id = id
;

# The above, but including descendant tags (counted as separate tags)

CALL descendant_tags_id_from("tmptable", "'tagname'");

SELECT name, tag_id, x, y, w, h
FROM file
JOIN (
    SELECT file_id, tag_id, x, y, w, h
    FROM instance
    JOIN (
        SELECT instance_id, tag_id
        FROM instance2tag
        JOIN tmptable tt ON tt.node = tag_id
    ) A ON A.instance_id = id
) B ON B.file_id = id
;


# The above, but descendant tags counted as their heirarchical root

## Procedures

DROP PROCEDURE IF EXISTS descendant_tags_id_rooted_init;
DROP PROCEDURE IF EXISTS descendant_tags_id_rooted_preseeded;
DROP PROCEDURE IF EXISTS descendant_tags_id_rooted_from;

delimiter $$

CREATE PROCEDURE descendant_tags_id_rooted_init(tbl VARBINARY(1024))
BEGIN
    set @query = concat("DROP TABLE IF EXISTS ", tbl, ";");
    PREPARE stmt FROM @query;
    EXECUTE stmt;
    
    set @query = concat("CREATE TEMPORARY TABLE ", tbl, " (node BIGINT UNSIGNED PRIMARY KEY,  root BIGINT UNSIGNED NOT NULL);");
    PREPARE stmt FROM @query;
    EXECUTE stmt;
END $$

CREATE PROCEDURE descendant_tags_id_rooted_preseeded(tbl VARBINARY(1024))
BEGIN
    set @query_b = concat("INSERT IGNORE INTO _tmp SELECT tag_id, root FROM ", tbl, " JOIN tag2parent ON node = parent_id;");
    set @query_d = concat("INSERT IGNORE INTO ", tbl, " SELECT node, root FROM _tmp;");
    PREPARE stmt_b FROM @query_b;
    PREPARE stmt_d FROM @query_d;
    REPEAT
        TRUNCATE TABLE _tmp;
        EXECUTE stmt_b;
        EXECUTE stmt_d;
    UNTIL ROW_COUNT() = 0
    END REPEAT;
END $$

CREATE PROCEDURE descendant_tags_id_rooted_from(tbl VARBINARY(1024),  str VARBINARY(1024))
BEGIN
    CALL descendant_tags_id_rooted_init(tbl);
    set @query = concat("INSERT INTO ", tbl, " (node, root) SELECT id, id FROM tag WHERE name IN (", str, ");");
    PREPARE stmt FROM @query;
    EXECUTE stmt;
    
    
    DROP TABLE IF EXISTS _tmp;
    
    set @query = concat("CREATE TEMPORARY TABLE _tmp LIKE ", tbl, ";");
    PREPARE stmt FROM @query;
    EXECUTE stmt;
    
    
    CALL descendant_tags_id_rooted_preseeded(tbl);
END $$

delimiter ;


## Usage

CALL descendant_tags_id_rooted_from("tmptable", "'foo','bar'");

SELECT name, root, x, y, w, h
FROM file
JOIN (
    SELECT DISTINCT file_id, root, x, y, w, h
    FROM instance
    JOIN (
        SELECT instance_id, tt.root
        FROM instance2tag
        JOIN tmptable tt ON tt.node = tag_id
    ) A ON A.instance_id = id
) B ON B.file_id = id
;





# List combined coordinates (i.e. minimum spanning rectangle) in files covering combinations of instances with relations tagged RTAG where the master has the tag ITAG1 and the slave has the tag ITAG2

CALL descendant_tags_id_from("rtag", "'ActionTag'");
CALL descendant_tags_id_from("mtag", "'MasterTag(the doer)'");
CALL descendant_tags_id_from("stag", "'SlaveTag(the acted on object)'");

SELECT name, x, y, w, h
FROM file
JOIN (
    SELECT file_id, MIN(x) AS x, MIN(y) AS y, MAX(x+w) - MIN(x) AS w, MAX(h+y) - MIN(y) AS h
    FROM instance
    JOIN (
        SELECT master_id, slave_id
        FROM relation
        JOIN (
            SELECT relation_id
            FROM relation2tag
            WHERE tag_id IN (SELECT node FROM rtag)
        ) R2T ON R2T.relation_id = id
        WHERE master_id IN (
            SELECT instance_id
            FROM instance2tag
            WHERE tag_id IN (SELECT node FROM mtag)
        )
        AND slave_id IN (
            SELECT instance_id
            FROM instance2tag
            WHERE tag_id IN (SELECT node FROM stag)
        )
    ) A ON A.master_id = id
        OR A.slave_id = id
    GROUP BY file_id, A.slave_id
) B ON B.file_id = id
;















# List all parents of a tag (this heirarchy is a tree structure)

## Procedures

DROP PROCEDURE IF EXISTS ancestor_tags_id_rooted_init;
DROP PROCEDURE IF EXISTS ancestor_tags_id_rooted_preseeded;
DROP PROCEDURE IF EXISTS ancestor_tags_id_rooted_from_id;

delimiter $$

CREATE PROCEDURE ancestor_tags_id_rooted_init(tbl VARBINARY(1024))
BEGIN
    set @query = concat("DROP TABLE IF EXISTS ", tbl, ";");
    PREPARE stmt FROM @query;
    EXECUTE stmt;
    
    set @query = concat("CREATE TEMPORARY TABLE ", tbl, " (node BIGINT UNSIGNED,  parent BIGINT UNSIGNED NOT NULL,  PRIMARY KEY `node2parent` (`node`, `parent`));");
    PREPARE stmt FROM @query;
    EXECUTE stmt;
END $$

CREATE PROCEDURE ancestor_tags_id_rooted_preseeded(tbl VARBINARY(1024))
BEGIN
    set @query_b = concat("INSERT IGNORE INTO _tmp SELECT tag_id, parent_id FROM ", tbl, " JOIN tag2parent ON tag_id = parent;");
    set @query_d = concat("INSERT IGNORE INTO ", tbl, " SELECT node, parent FROM _tmp;");
    PREPARE stmt_b FROM @query_b;
    PREPARE stmt_d FROM @query_d;
    REPEAT
        TRUNCATE TABLE _tmp;
        EXECUTE stmt_b;
        EXECUTE stmt_d;
    UNTIL ROW_COUNT() = 0
    END REPEAT;
END $$

CREATE PROCEDURE ancestor_tags_id_rooted_from_id(tbl VARBINARY(1024),  tag_id INT)
BEGIN
    CALL ancestor_tags_id_rooted_init(tbl);
    set @query = concat("INSERT INTO ", tbl, " SELECT ", tag_id, ", parent_id FROM tag2parent WHERE tag_id=", tag_id, ";");
    PREPARE stmt FROM @query;
    EXECUTE stmt;
    
    
    DROP TABLE IF EXISTS _tmp;
    
    set @query = concat("CREATE TEMPORARY TABLE _tmp LIKE ", tbl, ";");
    PREPARE stmt FROM @query;
    EXECUTE stmt;
    
    
    CALL ancestor_tags_id_rooted_preseeded(tbl);
END $$

delimiter ;


CALL ancestor_tags_id_rooted_from_id("foobar", 90);
SELECT * FROM foobar;
